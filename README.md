## Lab3 
### Variant 5

Якщо розрізняти поняття паралельності та одночасності виконання обчислень згідно з [1](http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html), [2](https://takuti.me/note/parallel-vs-concurrent/) чи [3](https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/), то 

**Паралельність:**

**Go:** Максимальна кількість файлів, що програма на Go може обробляти *паралельно* дорівнює **4**, що є числом процесорів (logical CPUs), які доступні на машині. Їх кількість є добутком Physical cores * Threads per core, в нашому випадку 2х2. Це можна перевірити , наприклад, за допомогою runtime.GOMAXPROCS(-1), що поверне кількість потоків ОС, які надані програмі. Автоматично встановлюється Go як кількість CPU починаючи з Go1.5, в більш старих версіях - 1.

**JS:** Кількість файлів, які можуть оброблятися паралельно рівна **1**, так як сама програма завжди виконується на одному потоці, одночасність же забезпечується непаралельним шляхом.

З приводу **одночасності**:

Nodejs реалізовує асинхронність через event loop i ми можемо спробувати вирахувати максимальну кількість файлів, які можемо обробити асинхронно. Вся черга в event loop зберігатиметься в оперативній пам'яті, а отже кількість файлів можна вирахувати знаючи кількість доступної прoцесу пам'яті, а також кількість пам'яті,що виділяється на один файл. На один файл виділяється не більше 4000 байт пам'яті. Перевірка відбувалася на машині з 8 гб = 8* 1024 * 1024 б = 8388608 б оперативної пам'яті, а отже **теоретично** можна асинхронно обробити 8388608/4000 = **2097** файлів. В го, теоретично, ця кількість буде трохи більшою через меншу кількість пам'яті, що виділяється на рутину.
На практиці частина оперативної пам'яті йде на підтримку ОС та інші процеси, що запущені користувачем, тому оцінка й є теоретичною.

