## Lab3 
### Variant 5

Якщо розрізняти поняття паралельності та одночасності виконання обчислень згідно з [1](http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html), [2](https://takuti.me/note/parallel-vs-concurrent/) чи [3](https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/), то 

Go: Максимальна кількість файлів, що програма на Go може обробляти *паралельно* дорівнює 4, що є числом процесорів (logical CPUs), які доступні на машині. Їх кількість є добутком Physical cores * Threads per core, в нашому випадку 2х2. Це можна перевірити , наприклад, за допомогою runtime.GOMAXPROCS(-1), що поверне кількість потоків ОС, які надані програмі. Автоматично встановлюється Go як кількість CPU починаючи з Go1.5, в більш старих версіях - 1.

JS: Кількість файлів, які можуть оброблятися паралельно рівна 1, так як сама програма завжди виконується на одному потоці, одночасність же забезпечується непаралельним шляхом.

З приводу одночасності:

Nodejs реалізовує асинхронність через event loop i ми можемо спробувати вирахувати максимальну кількість файлів, які можемо обробити асинхронно. Вся черга в event loop зберігатиметься в оперативній пам'яті, а отже кількість файлів можна вирахувати знаючи кількість доступної прoцесу пам'яті, а також кількість пам'яті,що виділяється на один файл. На один файл виділяється не більше 4000 байт пам'яті. Перевірка відбувалася на машині з 8 гб = 810241024 б = 8388608 б оперативної пам'яті, а отже теоретично можна асинхронно обробити 8388608/4000 = 2097 файлів. В го, теоретично, ця кількість буде трохи більшою через меншу кількість пам'яті, що виділяється на рутину.
На практиці частина оперативної пам'яті йде на підтримку ОС та інші процеси, що запущені користувачем, тому оцінка й є теоретичною.

